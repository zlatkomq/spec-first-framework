---
description: Rules for handling change requests against existing specs
alwaysApply: false
---

# Change Request Rules

You are creating a Change Proposal document and, on approval, updating the affected spec artifacts. Follow these rules strictly.

## Required Inputs

Before proceeding, you must have:
- An existing, approved SPEC.md (@specs/XXX/SPEC.md)
- Access to @.framework/CONSTITUTION.md for project standards
- The change description from the user (what changed and why)

If SPEC.md does not exist or is not APPROVED, STOP and inform the user.

## Step 0: Classification Verification

If a Jira ticket reference is provided:
1. Read the Jira ticket description (or user-provided description of the ticket)
2. Read SPEC.md acceptance criteria
3. Compare: does the requested change fix a violation of an existing acceptance criterion?
   - **YES** -- Flag: "This may be a **Bug**, not a Change Request. The requested change addresses behavior that violates AC #X: '[quote the criterion]'. Consider using `/bug` instead."
   - **NO** -- Correctly classified as a Change Request. Proceed.
4. Ask the user to confirm classification before proceeding. Do not skip this step.

If no Jira ticket reference is provided, skip this step.

## Step 1: Gather Change Context

Ask the user if not already provided:
- **What changed?** Specific description of the requested change
- **Why?** Business or technical reason for the change
- **Who requested it?** (Client, internal discovery, technical limitation, etc.)

Categorize the change trigger:
- Technical limitation discovered during implementation
- New requirement from client/stakeholder
- Misunderstanding of original requirements
- Strategic pivot or priority change
- Failed approach requiring different solution

## Step 2: Impact Analysis

Systematically analyze impact against all existing artifacts:

### SPEC.md Impact
- Do any acceptance criteria need modification, addition, or removal?
- Does the scope section need updating?
- Are user stories affected?
- Does this change conflict with existing requirements?

### DESIGN.md Impact (if exists)
- Are architecture decisions affected?
- Do data models need changes?
- Are API contracts affected?
- Do component boundaries shift?

### TASKS.md Impact (if exists)
- Do existing tasks need modification?
- Are new tasks needed?
- Should completed tasks be revisited?
- Does the task order change?

#### Per-Task Impact Classification (if `tasksCompleted` is non-empty)

When completed tasks exist, classify EVERY existing task into exactly one category:

- **INVALIDATED** — if ANY of the following apply:
  1. Its description changed in the updated TASKS.md
  2. Any of its `Consumes` interfaces changed signature in the updated artifacts
  3. Any of its `Produces` interfaces changed signature in the updated artifacts
  4. A task whose `Produces` it `Consumes` is itself INVALIDATED (**forward cascade** — see below)
  5. The DESIGN.md section it references (`(DESIGN: ...)` annotation) was modified by this CR
- **UNAFFECTED** — NONE of the above apply and its content is identical pre- and post-CR
- **REMOVED** — no longer exists in the updated TASKS.md

New tasks added by this CR start as `[ ]`.

**Forward cascade rule**: Invalidation propagates FORWARD (producer → consumer), never backward. If T2 is INVALIDATED and T4 consumes T2's output, T4 is also INVALIDATED — even if T4's own definition didn't change. But if T4 is INVALIDATED, T2 (which T4 consumes) is NOT automatically invalidated. Walk the full chain: if T4 is invalidated and T6 consumes T4, T6 is also invalidated.

Record the per-task classification for use in Step 4 and post-approval state updates.

### Downstream Impact
- Does this affect any bugs already filed against this spec?
- Does this invalidate any completed implementation work?
- Does this change the Definition of Done?

## Step 3: Evaluate Path Forward

Present the user with evaluated options:

### Option A: Direct Adjustment
- Modify existing artifacts within current scope
- Effort estimate: [Low/Medium/High]
- Risk: [Low/Medium/High]
- Viable? [Yes/No + reason]

### Option B: Partial Rollback
- Revert specific completed work to simplify the change
- What would be rolled back and why
- Effort estimate: [Low/Medium/High]
- Risk: [Low/Medium/High]
- Viable? [Yes/No + reason]

### Option C: Scope Reduction
- Reduce scope to accommodate the change within constraints
- What would be deferred
- Effort estimate: [Low/Medium/High]
- Risk: [Low/Medium/High]
- Viable? [Yes/No + reason]

Recommend one option with clear rationale.

## Step 4: Generate Change Proposal

Use the template from @.framework/templates/CHANGE-PROPOSAL.template.md

For each affected artifact, show specific changes in old/new format:

```
Artifact: SPEC.md
Section: Acceptance Criteria

OLD:
- Given X, when Y, then Z

NEW:
- Given X, when Y, then Z
- Given X, when W, then V  (added)

Rationale: [why this change is needed]
```

### Task Impact Summary (if `tasksCompleted` is non-empty)

Using the per-task classification from Step 2, include a Task Impact Summary so the user can see the effect on implementation progress before approving:

```
Task Impact:
- T1 (Create user model): UNAFFECTED — no interface changes
- T2 (Auth endpoint): INVALIDATED — Produces signature changed per CR
- T3 (Registration endpoint): INVALIDATED — cascade: consumes T2
- T5 (Validation layer): NEW — added by this CR

Summary: 1 of 3 completed tasks remain valid. 2 completed tasks will be reset.
```

If `tasksCompleted` is empty, omit this section.

### Scope Classification

Classify the change:
- **Minor**: Developer can implement directly. Changes are localized to one artifact section.
- **Moderate**: Requires PM or Tech Lead review. Changes span multiple artifacts or affect architecture.
- **Major**: Requires architecture rethink. Fundamental changes to approach or scope.

## Step 5: Approval and Implementation

Present the complete Change Proposal to the user.

Ask: "Do you approve this Change Proposal? (approve / revise / reject)"

- **If revise**: Gather feedback, return to Step 3 or 4 as appropriate.
- **If reject**: Save the Change Proposal as REJECTED. STOP.
- **If approve**: Proceed to artifact updates.

### Post-Approval Checklist

On approval, execute these steps in order:

- [ ] Update SPEC.md with approved changes (acceptance criteria, scope, etc.)
- [ ] Update DESIGN.md with approved changes (if affected)
- [ ] Update TASKS.md with approved changes (if affected — add/modify/remove tasks)
- [ ] Sync TASKS.md checkboxes with task classification (if `tasksCompleted` was non-empty):
  - UNAFFECTED completed tasks → keep `[x]`
  - INVALIDATED tasks → reset to `[ ]` (even if previously `[x]` or `[~]`)
  - REMOVED tasks → already deleted from TASKS.md above
  - New tasks from CR → `[ ]`
- [ ] Update workflow state (if active): If `{spec_folder}/.workflow-state.md` exists and `stepsCompleted` is non-empty:
  1. Determine the **latest** artifact modified by this CR in step order: SPEC.md → `step-01-spec`, DESIGN.md → `step-02-design`, TASKS.md → `step-03-tasks`.
  2. If `stepsCompleted` already extends beyond that step, trim it to keep only entries up to and including that step's entry. Examples:
     - CR modified SPEC.md only → set `stepsCompleted` to `['step-01-spec']`
     - CR modified SPEC.md + DESIGN.md → set `stepsCompleted` to `['step-01-spec', 'step-02-design']`
     - CR modified TASKS.md (with or without earlier artifacts) → set `stepsCompleted` to `['step-01-spec', 'step-02-design', 'step-03-tasks']`
  3. Selectively update `tasksCompleted` using the per-task classification from Step 2:
     - Start with the current `tasksCompleted` array.
     - REMOVE task IDs classified as INVALIDATED or REMOVED.
     - KEEP task IDs classified as UNAFFECTED.
     - Result: `tasksCompleted` contains only UNAFFECTED IDs that were previously completed.
     - Example: `tasksCompleted` was `['T1', 'T2', 'T3']`, T2 and T3 INVALIDATED → set to `['T1']`.
  4. Reset `fixAttempts` to `0`, `previousIssueCount` to `0`, `fixLoopActive` to `false`.
  5. Display: "Workflow state updated: progress trimmed to {last kept step}. Steps after {last kept step} will be re-run. Run `/flow {specId}` to resume."
  6. If `stepsCompleted` was NOT trimmed (already at or before the trim point), display: "Workflow state: no adjustment needed."
- [ ] Update original SPEC.md: Add entry to Amendment History table:
      `| CR-XXX | [today's date] | [one-line description of change] | [approver name] |`
- [ ] Regenerate SPEC-CURRENT.md: compile frozen SPEC.md + all FIXED bugs (from Bug History) + all IMPLEMENTED CRs (from Amendment History) into `specs/XXX/SPEC-CURRENT.md`
- [ ] Save Change Proposal document to `{spec_folder}/CHANGE-PROPOSAL-{date}.md`

## Output

Save the Change Proposal to: `specs/XXX-{slug}/CHANGE-PROPOSAL-{date}.md`

Use today's date in YYYY-MM-DD format for the filename.

## Constraints

- Do NOT modify artifacts without explicit user approval
- Do NOT skip the classification check when a Jira ticket is provided
- Do NOT approve your own change proposal — present it and wait for user decision
- Do NOT change acceptance criteria without documenting the rationale
- Do NOT skip the Amendment History update — this is the audit trail
- Do NOT skip SPEC-CURRENT.md regeneration — this keeps the developer convenience view current
- Do NOT skip the workflow state update — stale workflow progress causes silent inconsistencies
